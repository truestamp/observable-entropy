{
  "stories": [
    {
      "by": "0xedb",
      "descendants": 0,
      "id": 31152118,
      "score": 1,
      "time": 1650877910,
      "title": "A plain English introduction to CAP theorem",
      "type": "story",
      "url": "http://ksat.me/a-plain-english-introduction-to-cap-theorem"
    },
    {
      "by": "simonebrunozzi",
      "descendants": 0,
      "id": 31152117,
      "score": 1,
      "time": 1650877906,
      "title": "Hubbert's “Peak Oil” Theory",
      "type": "story",
      "url": "https://en.wikipedia.org/wiki/Hubbert_peak_theory"
    },
    {
      "by": "vitabenes",
      "descendants": 0,
      "id": 31152097,
      "score": 1,
      "time": 1650877739,
      "title": "Amazon Astro Is the Cute Face That Makes Tech Feel Like a Friend",
      "type": "story",
      "url": "https://www.cnet.com/home/smart-home/amazon-astro-is-the-cute-face-that-could-make-you-treat-tech-like-your-friend/"
    },
    {
      "by": "nrdvana",
      "descendants": 0,
      "id": 31152087,
      "score": 1,
      "text": "and also, &quot;how well did it work?&quot;<p>But let me clarify exactly what I&#x27;m asking here, because concepts like &quot;coroutines&quot; or &quot;cooperative multitasking&quot; or &quot;multiprocessing&quot; get heavily influenced by their implementation in each language, and I&#x27;m asking for a very specific implementation.<p>In a stack-based function-call language, there is usually a simple API of blocking I&#x2F;O where the state of each in-progress function is preserved on a stack as the entire thread of execution is paused until the completion of the I&#x2F;O.  This leads to very clear and easy-to-debug programs, usually with the added convenience of throwing and catching exceptions, but you can only process one I&#x2F;O sequence (client&#x2F;server conversation, etc) per thread.  Moving to multiple threads or parallel processes lead to complex concurrency problems, and often don&#x27;t scale well.<p>Languages usually also provide more complex secondary APIs for non-blocking I&#x2F;O that allows a function to start an I&#x2F;O operation and continue doing other things while checking the status of the I&#x2F;O, or blocking on an event API to wake up when something is ready.  Taken to its logical conclusion, the program becomes structured around an event loop, but the programmer must now track the on-going state of a particular I&#x2F;O sequence in their own data structures without the convenience of a stack-based tree of function calls.  You can no longer use normal language exceptions to abort a single I&#x2F;O conversation because it is interleaved with other conversations and the logical call-tree is gone.  The program must also avoid using any library which makes use of blocking APIs, dividing the library ecosystem into &quot;blocking&quot; and &quot;nonblocking-compatible&quot; halves.<p>One solution is to add co-routines to a language, where multiple function-call tree stacks are held in memory, and executed on a single thread.  Any time a blocking API is used, the language starts the I&#x2F;O operation then switches to another co-routine that is ready to run.  In other words, the language manages the event loop hidden in the background while presenting the user with what appears to be normal threads, but without most of the hard synchronization that you need from true multithreading.  The downsides are that a function with a long-running calculation not involving I&#x2F;O will delay the processing of the I&#x2F;O of all other co-routines, and there might still be synchronization issues if I&#x2F;O operations are interleaved with changes to data structures.<p>Most scripting languages provide <i>something</i> for co-routines, but usually requiring some invasive changes to the code that are not just the simple blocking APIs presented by the stock language.<p>Python: the generators act like independent call stacks, and were made into &quot;co-routines&quot; with a send() call, but these do not tie into the native blocking API read&#x2F;write&#x2F;sleep to perform event-driven I&#x2F;O like I described above.  The co-routines are also used like objects instead of called like normal functions.<p>JavaScript: JS has the Async&#x2F;Await system which is almost what I describe, but they are exposed as keywords which must be used in the code, not passively compatible with other code using blocking I&#x2F;O.<p>Perl: there is a Coro library that switches the interpreter stacks, but does not intercept the blocking I&#x2F;O.  There are several &quot;AsyncAwait&quot; modules, with the same caveat as JS.<p>There are so many languages out there, I&#x27;m sure that someone has already implemented intrinsic co-routines + non-blocking I&#x2F;O exposed to the user as a simple blocking cooperative threads.  I want to know which languages have tried this, and maybe more importantly, if you have worked on a project that used them, how well the idea works in practice.",
      "time": 1650877665,
      "title": "Ask HN: What languages have true native cooperative multitasking?",
      "type": "story"
    },
    {
      "by": "tomayac",
      "descendants": 0,
      "id": 31152079,
      "score": 1,
      "time": 1650877546,
      "title": "Project Fugu API Showcase",
      "type": "story",
      "url": "https://developer.chrome.com/blog/fugu-showcase/"
    },
    {
      "by": "KeliaDen",
      "descendants": 1,
      "id": 31152048,
      "kids": [
        31152049
      ],
      "score": 1,
      "time": 1650877263,
      "title": "How Does Prima Weight Loss Pills UK Function?",
      "type": "story",
      "url": "https://www.jpost.com/promocontent/prima-weight-loss-pills-uk-is-prima-diet-capsule-legitimate-or-scam-703262"
    },
    {
      "by": "maydemir",
      "descendants": 0,
      "id": 31152046,
      "score": 1,
      "time": 1650877226,
      "title": "Core – The complete web scraping toolkit for PHP",
      "type": "story",
      "url": "https://github.com/roach-php/core"
    },
    {
      "by": "walrus01",
      "descendants": 0,
      "id": 31152018,
      "score": 1,
      "time": 1650876973,
      "title": "Red bull is denied FAA exemption, crashes Cessna 182 anyways",
      "type": "story",
      "url": "https://www.fox10phoenix.com/news/plane-swap-stunt-crash-arizona-feds-denied-safety-exemption-red-bull"
    },
    {
      "by": "tboerstad",
      "descendants": 0,
      "id": 31151998,
      "score": 1,
      "time": 1650876788,
      "title": "New Texts Shed Light on Elon Musk’s 2018 Spat with Saudi Fund",
      "type": "story",
      "url": "https://www.bloomberg.com/news/articles/2022-04-25/-weak-sauce-taunt-highlights-musk-s-2018-spat-with-saudi-fund"
    },
    {
      "by": "afrcnc",
      "descendants": 0,
      "id": 31151977,
      "score": 1,
      "time": 1650876519,
      "title": "Brinc Supplies Ukraine Drones Capable of Breaking Through Glass",
      "type": "story",
      "url": "https://www.iphoneincanada.ca/news/brinc-drones-can-break-through-glass/"
    }
  ]
}