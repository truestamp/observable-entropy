{
  "stories": [
    {
      "by": "wyrm",
      "descendants": 0,
      "id": 29398250,
      "score": 1,
      "time": 1638311001,
      "title": "Passing on a Musical Love Letter to the Next Generation",
      "type": "story",
      "url": "http://blog.archive.org/2021/11/29/passing-on-a-musical-love-letter-to-the-next-generation/"
    },
    {
      "by": "Cieplak",
      "descendants": 0,
      "id": 29398246,
      "score": 1,
      "time": 1638310979,
      "title": "Augmenting Human Intellect: A Conceptual Framework (1962)",
      "type": "story",
      "url": "https://web.archive.org/web/20110504035147/http://www.dougengelbart.org/pubs/augment-3906.html"
    },
    {
      "by": "tosh",
      "descendants": 0,
      "id": 29398242,
      "score": 1,
      "time": 1638310917,
      "title": "gcry_mpi_sub_ui result is positive when it should be negative",
      "type": "story",
      "url": "https://lists.gnupg.org/pipermail/gcrypt-devel/2021-November/005191.html"
    },
    {
      "by": "arkadiyt",
      "descendants": 0,
      "id": 29398216,
      "score": 2,
      "time": 1638310774,
      "title": "Discovering Full Read SSRF in Jamf (CVE-2021-39303 and CVE-2021-40809)",
      "type": "story",
      "url": "https://blog.assetnote.io/2021/11/30/jamf-ssrf/"
    },
    {
      "by": "rococode",
      "descendants": 0,
      "id": 29398209,
      "score": 1,
      "time": 1638310705,
      "title": "Introducing the Icelandverse [video]",
      "type": "story",
      "url": "https://www.youtube.com/watch?v=enMwwQy_noI"
    },
    {
      "by": "feross",
      "descendants": 0,
      "id": 29398201,
      "score": 1,
      "time": 1638310660,
      "title": "Apple Podcasts presents the Best of 2021",
      "type": "story",
      "url": "https://www.apple.com/newsroom/2021/11/apple-podcasts-presents-the-best-of-2021/"
    },
    {
      "by": "MKais",
      "descendants": 0,
      "id": 29398187,
      "score": 2,
      "time": 1638310552,
      "title": "Cancer therapy from Princeton holds potential to switch off major cancer types",
      "type": "story",
      "url": "https://www.princeton.edu/news/2021/11/29/new-cancer-therapy-yibin-kangs-lab-holds-potential-switch-major-cancer-types"
    },
    {
      "by": "armona",
      "descendants": 0,
      "id": 29398180,
      "score": 2,
      "text": "I am familiar with this one: https:&#x2F;&#x2F;www.math3ma.com&#x2F;.<p>Any other suggestions?",
      "time": 1638310485,
      "title": "Ask HN: Interesting mathematics blogs?",
      "type": "story"
    },
    {
      "by": "eezurr",
      "descendants": 0,
      "id": 29398147,
      "score": 2,
      "text": "Hello HN<p>TL;DR: I probably created the fastest &quot;find all K simple paths&quot; algorithm for a weighted or unweighted, directed or undirected graph. How would I, as an outsider, publish the results? If I&#x27;m right, I&#x27;d like to benefit from this discovery to open doors to more interesting work&#x2F;careers. (I fear, in my 30s, I am at a huge disadvantage for not having any big co. or university to list on my resume)<p>Background:<p>I am outside of the tech &quot;scene&quot; and have no tech&#x2F;academia connections (self taught, no time spent in university). That being said, I&#x27;ve been programming and managing operations (working as the sole dev at small co.) for 10+ years. I recently quit my job to reevaluate my career path and for fun, started working on a city builder video game. The first big problem I had to solve was &quot;how can I efficiently simulate people&#x2F;cars utilizing ALL the fastest paths available to them?&quot; (in case you aren&#x27;t aware, Dijkstra&#x27;s algorithm only returns one shortest path from start to destination).<p>Solution:<p>I created an algorithm that has a time complexity of around O((V+E)log V) and a space complexity of O(n) (for a single node to all other nodes, for all possible shortest paths from each possible destination node to the source node).<p>Now:<p>I tested the algorithm in my game world and watched my digital citizens utilize all the shortest paths available to them for various destinations around the map. For a heavy load test, I created a 100 x 100 grid (where each square is a node), and my code takes 1.75 times longer than Dijkstra&#x27;s. Since I can store the search tree I created, I can move tens of thousands of units around the map without any lag (using SFML vertex arrays for efficiently handling the screen draws).<p>I started researching other existing solutions and to my surprise, my solution is faster. Eppstein (1997) is the fastest solution I came across @ O(E + V log V + kV), where k can grow at some binomial coefficient (thus would be terribly inefficient with hundreds of nodes, let alone thousands, if many fastest paths existed, which is the reality of most cities if you walk).<p>Other notes (excuse my lack of traditional education here):<p>This does not prove P = NP (phew! I&#x27;m safe.). While the number of shortest paths can grow at some binomial coefficient, the classification of all possible paths does not. To explain by example: Going from node (A) to node (G) could possibly use nodes (B, C, D, E, F) along the way. So A--&gt;G is a classification. When we add a new node (H) to (G), that (A) can only get to via (G), the A--&gt;G classification is not changed. On the other hand, if every node connected to every other node, the amount of classifications would increase at an exponential rate (and devolve into all NP-Complete problems), and the possible amount of k paths (not necessarily shortest) would grow super-binomial coefficient-ly.",
      "time": 1638310234,
      "title": "Ask HN: As an outsider, how could I publish a white paper?",
      "type": "story"
    },
    {
      "by": "gigama",
      "descendants": 0,
      "id": 29398137,
      "score": 1,
      "time": 1638310191,
      "title": "China Is Winning the Big Data War",
      "type": "story",
      "url": "https://www.nytimes.com/2021/11/30/opinion/xi-jinping-china-us-data-war.html"
    }
  ]
}