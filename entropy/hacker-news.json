{
  "stories": [
    {
      "by": "walterbell",
      "descendants": 0,
      "id": 29669533,
      "score": 1,
      "time": 1640314655,
      "title": "Rogel Aguilera-Mederos Rejected a Plea Deal. So He Got 110 Years in Prison",
      "type": "story",
      "url": "https://reason.com/2021/12/22/rogel-aguilera-mederos-rejected-a-plea-deal-so-he-got-110-years-in-prison/"
    },
    {
      "by": "RKearney",
      "descendants": 0,
      "id": 29669512,
      "score": 1,
      "time": 1640314427,
      "title": "Swift for Visual Studio Code",
      "type": "story",
      "url": "https://forums.swift.org/t/introducing-swift-for-visual-studio-code/54246"
    },
    {
      "by": "razorburn",
      "descendants": 0,
      "id": 29669481,
      "score": 1,
      "time": 1640314156,
      "title": "The Automatic Muse: GPT-3 as Clairvoyant",
      "type": "story",
      "url": "https://www.roughtype.com/?p=9100"
    },
    {
      "by": "nwj",
      "descendants": 0,
      "id": 29669463,
      "score": 1,
      "time": 1640314039,
      "title": "Statistical Imaginaries: An Ode to Responsible Data Science",
      "type": "story",
      "url": "https://zephoria.substack.com/p/statistical-imaginaries"
    },
    {
      "by": "pawurb",
      "descendants": 0,
      "id": 29669461,
      "score": 1,
      "time": 1640314025,
      "title": "Show HN: PG Extras – a set of tools for debugging PostgreSQL performance issues",
      "type": "story",
      "url": "https://pawelurbanek.com/postgresql-fix-performance"
    },
    {
      "by": "belated_tech",
      "descendants": 0,
      "id": 29669427,
      "score": 1,
      "time": 1640313827,
      "title": "Apple Media Services and Apple Platforms’ Locale Problem – A Tip and Its Iceberg",
      "type": "story",
      "url": "https://starlite.me/en/Tech-Talks/Apple-Media-Services-and-Apple-Platforms-Locale-Problem-A-Tip-and-Its-Iceberg/"
    },
    {
      "by": "belter",
      "descendants": 2,
      "id": 29669418,
      "kids": [
        29669501,
        29669419
      ],
      "score": 1,
      "time": 1640313744,
      "title": "29 Days on the Edge",
      "type": "story",
      "url": "https://www.youtube.com/watch?v=uUAvXYW5bmI"
    },
    {
      "by": "johnnyApplePRNG",
      "descendants": 1,
      "id": 29669354,
      "kids": [
        29669455,
        29669368
      ],
      "score": 2,
      "text": "I am attempting to create an poker tournament software and I am getting hung up on how exactly to keep track of hands, dealer&#x2F;action position, tables, and tournaments.<p>In my eyes there are three things that need to be tracked.<p>Hands, which are a subset of Tables, which are a subset or Tournaments.<p>I&#x27;ve created the idea of a *<i>tournament_registration*</i> table that simply stores the *<i>account_id*</i> of the eager player and the *<i>tournament_size*</i> of the size of tournament they&#x27;re after.<p>Whenever a new *<i>account_id*</i> is added to the *<i>tournament_registration*</i> table for a certain *<i>tournament_size*</i>, I query the table after the insert to determine if enough players have registered for a certain tournament size.<p>That setup seems fairly optimal.<p>But when it comes to seating players at a table... I am confusing myself (probably overthinking this) as to how exactly to keep track of hand progression at each table.<p>Any help&#x2F;direction would be greatly appreciated.<p>Cheers!<p>I did try researching this of course, but any search for &quot;poker database best practices&quot; only turns up countless poker tracking softwares.<p>And unfortunately not many private poker websites talk at length about their setups.",
      "time": 1640313193,
      "title": "Ask HN: How would you keep track of a live poker tournament's state?",
      "type": "story"
    },
    {
      "by": "vanusa",
      "descendants": 1,
      "id": 29669340,
      "kids": [
        29669353
      ],
      "score": 1,
      "time": 1640312970,
      "title": "The Absurdity of Renting a Car Will No Longer Be Tolerated",
      "type": "story",
      "url": "https://www.theatlantic.com/technology/archive/2021/12/car-rental-shortage-covid/621068/"
    },
    {
      "by": "utilityhotbar",
      "descendants": 0,
      "id": 29669327,
      "score": 2,
      "text": "The biggest difference in my mind between how computer science is assessed and how computer programming works in practice is the removal of context. Code in the whiteboard interview assignment and the CS classroom is pristine, perfect, isolated from all surrounding impurities. Any interfaces in and out of this plane of pure imagination are, like the blood-brain barrier, clearly marked and even more clearly defined, never complex or unknowable. The data comes in a format specified by the question and leaves in another, similar format, or is automatically captured when the output buffer is flushed. Actual, far more complex code works in the background (if code is executed in this fenced box) to ensure that the little frustrations of programming never intercede with what is perceived to be the pure core, the “true test” of one’s technical mettle.<p>Why is this a problem? The problem, in my view, is that the people selected through this process are woefully ill-equipped to deal with the practical nature of code - that is to say, how the practice of software development is carried out in the real world, so to speak. If code is the key to the digital era, then context is the key to code. Unless you are dealing with only hand-built computer hardware, almost all code you will write will build on the code written by others - often this is explicit, such as when you invoke a library, but just as often this is implicit, such as when you make use of a programming language whose interpreter has been constructed by another. Modern programming, then, is about the navigation of multifarious contexts. Any web developer will know this through the concept of the tech stack, layers of technologies that synthesise with each other to provide the necessary functionality modern web applications require, but the concept is far more universal than that. Any time we make use of multiple software suites, languages, modules or even scripts in the same project, we are combining contexts.<p>Contexts, of course, don’t always play well with each other. The dreaded dependency errors and data format incompatibilities are very often only the most surface sign of this issue - it can just as often be seen in the design patterns invoked by different libraries, differing approaches to similar problems like managing user sessions or data storage. The “little frustrations” we suffer each time we merge these different contexts are not just little frustrations, they are demonstrations of a different type of skill set, one that is, I would argue, just as if not more important than a theoretical grasp of how to reverse a binary tree. For complex problems people have always tried to create complex solutions, all-in-one platforms and ecosystems like Tensorflow for machine learning, but they will never be sufficient. More than bodging or hacking, the modern software engineer learns how to harmonise different contexts, and turn them into reliable, useful code that performs to specification. The ability to see a practical, context-sensitive problem, diagnose the source, look up a solution (likely on StackOverflow), and then implement that solution in a reliable way is just as valuable as the ability to turn a theoretical algorithm into equally theoretical code. After all, how many of us have needed to reverse a binary tree “by hand” in our work?<p>I have no grand thesis, no sudden twist to share, except what I have already told you. As code grows more complex, as our problems become more difficult to visualise and solve using a single context, the need for the context-confident engineer grows by the day. I just hope that we’ll be able to find them, when the time comes.",
      "time": 1640312889,
      "title": "Theory: Context Is the Key to Code",
      "type": "story"
    }
  ]
}