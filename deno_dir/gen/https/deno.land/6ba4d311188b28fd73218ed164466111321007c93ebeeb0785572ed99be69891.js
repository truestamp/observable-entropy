const noop = ()=>{};
class AsyncIterableClone {
    currentPromise;
    resolveCurrent = noop;
    consumed;
    consume = noop;
    constructor(){
        this.currentPromise = new Promise((resolve)=>{
            this.resolveCurrent = resolve;
        });
        this.consumed = new Promise((resolve)=>{
            this.consume = resolve;
        });
    }
    reset() {
        this.currentPromise = new Promise((resolve)=>{
            this.resolveCurrent = resolve;
        });
        this.consumed = new Promise((resolve)=>{
            this.consume = resolve;
        });
    }
    async next() {
        const res = await this.currentPromise;
        this.consume();
        this.reset();
        return res;
    }
    async push(res) {
        this.resolveCurrent(res);
        // Wait until current promise is consumed and next item is requested.
        await this.consumed;
    }
    [Symbol.asyncIterator]() {
        return this;
    }
}
/**
 * Branches the given async iterable into the n branches.
 *
 * Example:
 *
 *     const gen = async function* gen() {
 *       yield 1;
 *       yield 2;
 *       yield 3;
 *     }
 *
 *     const [branch1, branch2] = tee(gen());
 *
 *     (async () => {
 *       for await (const n of branch1) {
 *         console.log(n); // => 1, 2, 3
 *       }
 *     })();
 *
 *     (async () => {
 *       for await (const n of branch2) {
 *         console.log(n); // => 1, 2, 3
 *       }
 *     })();
 */ export function tee(src, n = 2) {
    const clones = Array.from({
        length: n
    }).map(()=>new AsyncIterableClone());
    (async ()=>{
        const iter = src[Symbol.asyncIterator]();
        await Promise.resolve();
        while(true){
            const res = iter.next();
            await Promise.all(clones.map((c)=>c.push(res)));
            if ((await res).done) {
                break;
            }
        }
    })().catch((e)=>{
        console.error(e);
    });
    return clones;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImh0dHBzOi8vZGVuby5sYW5kL3N0ZEAwLjk4LjAvYXN5bmMvdGVlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE4LTIwMjEgdGhlIERlbm8gYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIGxpY2Vuc2UuXG5cbi8vIFV0aWxpdHkgZm9yIHJlcHJlc2VudGluZyBuLXR1cGxlXG50eXBlIFR1cGxlPFQsIE4gZXh0ZW5kcyBudW1iZXI+ID0gTiBleHRlbmRzIE5cbiAgPyBudW1iZXIgZXh0ZW5kcyBOID8gVFtdIDogVHVwbGVPZjxULCBOLCBbXT5cbiAgOiBuZXZlcjtcbnR5cGUgVHVwbGVPZjxULCBOIGV4dGVuZHMgbnVtYmVyLCBSIGV4dGVuZHMgdW5rbm93bltdPiA9IFJbXCJsZW5ndGhcIl0gZXh0ZW5kcyBOXG4gID8gUlxuICA6IFR1cGxlT2Y8VCwgTiwgW1QsIC4uLlJdPjtcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG5jbGFzcyBBc3luY0l0ZXJhYmxlQ2xvbmU8VD4gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPFQ+IHtcbiAgY3VycmVudFByb21pc2U6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8VD4+O1xuICByZXNvbHZlQ3VycmVudDogKHg6IFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8VD4+KSA9PiB2b2lkID0gbm9vcDtcbiAgY29uc3VtZWQ6IFByb21pc2U8dm9pZD47XG4gIGNvbnN1bWU6ICgpID0+IHZvaWQgPSBub29wO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY3VycmVudFByb21pc2UgPSBuZXcgUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxUPj4oKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZUN1cnJlbnQgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIHRoaXMuY29uc3VtZWQgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5jb25zdW1lID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY3VycmVudFByb21pc2UgPSBuZXcgUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxUPj4oKHJlc29sdmUpID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZUN1cnJlbnQgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIHRoaXMuY29uc3VtZWQgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5jb25zdW1lID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIG5leHQoKTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxUPj4ge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuY3VycmVudFByb21pc2U7XG4gICAgdGhpcy5jb25zdW1lKCk7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICBhc3luYyBwdXNoKHJlczogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxUPj4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLnJlc29sdmVDdXJyZW50KHJlcyk7XG4gICAgLy8gV2FpdCB1bnRpbCBjdXJyZW50IHByb21pc2UgaXMgY29uc3VtZWQgYW5kIG5leHQgaXRlbSBpcyByZXF1ZXN0ZWQuXG4gICAgYXdhaXQgdGhpcy5jb25zdW1lZDtcbiAgfVxuXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTogQXN5bmNJdGVyYXRvcjxUPiB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLyoqXG4gKiBCcmFuY2hlcyB0aGUgZ2l2ZW4gYXN5bmMgaXRlcmFibGUgaW50byB0aGUgbiBicmFuY2hlcy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICBjb25zdCBnZW4gPSBhc3luYyBmdW5jdGlvbiogZ2VuKCkge1xuICogICAgICAgeWllbGQgMTtcbiAqICAgICAgIHlpZWxkIDI7XG4gKiAgICAgICB5aWVsZCAzO1xuICogICAgIH1cbiAqXG4gKiAgICAgY29uc3QgW2JyYW5jaDEsIGJyYW5jaDJdID0gdGVlKGdlbigpKTtcbiAqXG4gKiAgICAgKGFzeW5jICgpID0+IHtcbiAqICAgICAgIGZvciBhd2FpdCAoY29uc3QgbiBvZiBicmFuY2gxKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKG4pOyAvLyA9PiAxLCAyLCAzXG4gKiAgICAgICB9XG4gKiAgICAgfSkoKTtcbiAqXG4gKiAgICAgKGFzeW5jICgpID0+IHtcbiAqICAgICAgIGZvciBhd2FpdCAoY29uc3QgbiBvZiBicmFuY2gyKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKG4pOyAvLyA9PiAxLCAyLCAzXG4gKiAgICAgICB9XG4gKiAgICAgfSkoKTtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlZTxULCBOIGV4dGVuZHMgbnVtYmVyID0gMj4oXG4gIHNyYzogQXN5bmNJdGVyYWJsZTxUPixcbiAgbjogTiA9IDIgYXMgTixcbik6IFR1cGxlPEFzeW5jSXRlcmFibGU8VD4sIE4+IHtcbiAgY29uc3QgY2xvbmVzOiBUdXBsZTxBc3luY0l0ZXJhYmxlQ2xvbmU8VD4sIE4+ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogbiB9KS5tYXAoXG4gICAgKCkgPT4gbmV3IEFzeW5jSXRlcmFibGVDbG9uZSgpLFxuICAgIC8vIGRlbm8tbGludC1pZ25vcmUgbm8tZXhwbGljaXQtYW55XG4gICkgYXMgYW55O1xuICAoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGl0ZXIgPSBzcmNbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHJlcyA9IGl0ZXIubmV4dCgpO1xuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2xvbmVzLm1hcCgoYykgPT4gYy5wdXNoKHJlcykpKTtcbiAgICAgIGlmICgoYXdhaXQgcmVzKS5kb25lKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSkoKS5jYXRjaCgoZSkgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gIH0pO1xuICByZXR1cm4gY2xvbmVzO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVVBLE1BQU0sSUFBSSxHQUFHLElBQU0sRUFBRSxBQUFDO0FBRXRCLE1BQU0sa0JBQWtCO0lBQ3RCLGNBQWMsQ0FBNkI7SUFDM0MsY0FBYyxHQUE0QyxJQUFJLENBQUM7SUFDL0QsUUFBUSxDQUFnQjtJQUN4QixPQUFPLEdBQWUsSUFBSSxDQUFDO0lBRTNCLGFBQWM7UUFDWixJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksT0FBTyxDQUFvQixDQUFDLE9BQU8sR0FBSztZQUNoRSxJQUFJLENBQUMsY0FBYyxHQUFHLE9BQU8sQ0FBQztTQUMvQixDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksT0FBTyxDQUFPLENBQUMsT0FBTyxHQUFLO1lBQzdDLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1NBQ3hCLENBQUMsQ0FBQztLQUNKO0lBRUQsS0FBSyxHQUFHO1FBQ04sSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLE9BQU8sQ0FBb0IsQ0FBQyxPQUFPLEdBQUs7WUFDaEUsSUFBSSxDQUFDLGNBQWMsR0FBRyxPQUFPLENBQUM7U0FDL0IsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLE9BQU8sQ0FBTyxDQUFDLE9BQU8sR0FBSztZQUM3QyxJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztTQUN4QixDQUFDLENBQUM7S0FDSjtJQUVELE1BQU0sSUFBSSxHQUErQjtRQUN2QyxNQUFNLEdBQUcsR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLEFBQUM7UUFDdEMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ2YsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ2IsT0FBTyxHQUFHLENBQUM7S0FDWjtJQUVELE1BQU0sSUFBSSxDQUFDLEdBQStCLEVBQWlCO1FBQ3pELElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDekIscUVBQXFFO1FBQ3JFLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQztLQUNyQjtJQUVELENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxHQUFxQjtRQUN6QyxPQUFPLElBQUksQ0FBQztLQUNiO0NBQ0Y7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0JHLENBQ0gsT0FBTyxTQUFTLEdBQUcsQ0FDakIsR0FBcUIsRUFDckIsQ0FBSSxHQUFHLENBQUMsQUFBSyxFQUNlO0lBQzVCLE1BQU0sTUFBTSxHQUFvQyxLQUFLLENBQUMsSUFBSSxDQUFDO1FBQUUsTUFBTSxFQUFFLENBQUM7S0FBRSxDQUFDLENBQUMsR0FBRyxDQUMzRSxJQUFNLElBQUksa0JBQWtCLEVBQUUsQ0FFL0IsQUFBTyxBQUFDO0lBQ1QsQ0FBQyxVQUFZO1FBQ1gsTUFBTSxJQUFJLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsRUFBRSxBQUFDO1FBQ3pDLE1BQU0sT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQ3hCLE1BQU8sSUFBSSxDQUFFO1lBQ1gsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxBQUFDO1lBQ3hCLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xELElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRTtnQkFDcEIsTUFBTTthQUNQO1NBQ0Y7S0FDRixDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUs7UUFDaEIsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNsQixDQUFDLENBQUM7SUFDSCxPQUFPLE1BQU0sQ0FBQztDQUNmIn0=