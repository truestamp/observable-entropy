import { denoDelay } from "../deps.ts";
import { assertDefined, asyncDecorator } from "../misc.ts";
import { getDefaultRetryOptions, } from "./options.ts";
import { isTooManyTries, TooManyTries } from "./tooManyTries.ts";
export function retry(fn, retryOptions) {
    const fnAsync = asyncDecorator(fn);
    return retryAsync(fnAsync, retryOptions);
}
export async function retryAsync(fn, retryOptions) {
    const { maxTry, delay, until } = {
        ...getDefaultRetryOptions(),
        ...retryOptions,
    };
    assertDefined(maxTry, `maxTry must be defined`);
    assertDefined(delay, `delay must be defined`);
    const canRecall = () => maxTry > 1;
    const recall = async () => {
        await denoDelay(delay);
        return await retryAsync(fn, { delay, maxTry: maxTry - 1, until });
    };
    try {
        const result = await fn();
        const done = until ? until(result) : true;
        if (done) {
            return result;
        }
        else if (canRecall()) {
            return await recall();
        }
        else {
            throw new TooManyTries();
        }
    }
    catch (err) {
        if (!isTooManyTries(err) && canRecall()) {
            return await recall();
        }
        else {
            throw err;
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmV0cnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJyZXRyeS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQ3ZDLE9BQU8sRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLE1BQU0sWUFBWSxDQUFDO0FBQzNELE9BQU8sRUFFTCxzQkFBc0IsR0FFdkIsTUFBTSxjQUFjLENBQUM7QUFDdEIsT0FBTyxFQUFFLGNBQWMsRUFBRSxZQUFZLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQVFqRSxNQUFNLFVBQVUsS0FBSyxDQUNuQixFQUFxQixFQUNyQixZQUF3QztJQUV4QyxNQUFNLE9BQU8sR0FBRyxjQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDbkMsT0FBTyxVQUFVLENBQUMsT0FBTyxFQUFFLFlBQVksQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFRRCxNQUFNLENBQUMsS0FBSyxVQUFVLFVBQVUsQ0FDOUIsRUFBb0IsRUFDcEIsWUFBOEI7SUFFOUIsTUFBTSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEdBQUc7UUFDL0IsR0FBRyxzQkFBc0IsRUFBRTtRQUMzQixHQUFHLFlBQVk7S0FDaEIsQ0FBQztJQUNGLGFBQWEsQ0FBQyxNQUFNLEVBQUUsd0JBQXdCLENBQUMsQ0FBQztJQUNoRCxhQUFhLENBQUMsS0FBSyxFQUFFLHVCQUF1QixDQUFDLENBQUM7SUFDOUMsTUFBTSxTQUFTLEdBQUcsR0FBRyxFQUFFLENBQUMsTUFBTyxHQUFHLENBQUMsQ0FBQztJQUNwQyxNQUFNLE1BQU0sR0FBRyxLQUFLLElBQUksRUFBRTtRQUN4QixNQUFNLFNBQVMsQ0FBQyxLQUFNLENBQUMsQ0FBQztRQUN4QixPQUFPLE1BQU0sVUFBVSxDQUFDLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTyxHQUFHLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQ3JFLENBQUMsQ0FBQztJQUNGLElBQUk7UUFDRixNQUFNLE1BQU0sR0FBRyxNQUFNLEVBQUUsRUFBRSxDQUFDO1FBQzFCLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDMUMsSUFBSSxJQUFJLEVBQUU7WUFDUixPQUFPLE1BQU0sQ0FBQztTQUNmO2FBQU0sSUFBSSxTQUFTLEVBQUUsRUFBRTtZQUN0QixPQUFPLE1BQU0sTUFBTSxFQUFFLENBQUM7U0FDdkI7YUFBTTtZQUNMLE1BQU0sSUFBSSxZQUFZLEVBQUUsQ0FBQztTQUMxQjtLQUNGO0lBQUMsT0FBTyxHQUFHLEVBQUU7UUFDWixJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLFNBQVMsRUFBRSxFQUFFO1lBQ3ZDLE9BQU8sTUFBTSxNQUFNLEVBQUUsQ0FBQztTQUN2QjthQUFNO1lBQ0wsTUFBTSxHQUFHLENBQUM7U0FDWDtLQUNGO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBzaW5jZSAyMDIwLCBGcmFuY2tMZHguIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBsaWNlbnNlLlxuaW1wb3J0IHsgZGVub0RlbGF5IH0gZnJvbSBcIi4uL2RlcHMudHNcIjtcbmltcG9ydCB7IGFzc2VydERlZmluZWQsIGFzeW5jRGVjb3JhdG9yIH0gZnJvbSBcIi4uL21pc2MudHNcIjtcbmltcG9ydCB7XG4gIGRlZmF1bHRSZXRyeU9wdGlvbnMsXG4gIGdldERlZmF1bHRSZXRyeU9wdGlvbnMsXG4gIFJldHJ5T3B0aW9ucyxcbn0gZnJvbSBcIi4vb3B0aW9ucy50c1wiO1xuaW1wb3J0IHsgaXNUb29NYW55VHJpZXMsIFRvb01hbnlUcmllcyB9IGZyb20gXCIuL3Rvb01hbnlUcmllcy50c1wiO1xuXG4vKiogXG4gKiBSZXRyeSBhIGZ1bmN0aW9uIHVudGlsIGl0IGRvZXMgbm90IHRocm93IGFuIGV4Y2VwdGlvbi5cbiAqICBcbiAqIEBwYXJhbSBmbiB0aGUgZnVuY3Rpb24gdG8gZXhlY3V0ZVxuICogQHBhcmFtIHJldHJ5T3B0aW9ucyByZXRyeSBvcHRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRyeTxSRVRVUk5fVFlQRT4oXG4gIGZuOiAoKSA9PiBSRVRVUk5fVFlQRSxcbiAgcmV0cnlPcHRpb25zPzogUmV0cnlPcHRpb25zPFJFVFVSTl9UWVBFPixcbik6IFByb21pc2U8UkVUVVJOX1RZUEU+IHtcbiAgY29uc3QgZm5Bc3luYyA9IGFzeW5jRGVjb3JhdG9yKGZuKTtcbiAgcmV0dXJuIHJldHJ5QXN5bmMoZm5Bc3luYywgcmV0cnlPcHRpb25zKTtcbn1cblxuLyoqIFxuICogUmV0cnkgYW4gYXN5bmMgZnVuY3Rpb24gdW50aWwgaXQgZG9lcyBub3QgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICogIFxuICogQHBhcmFtIGZuIHRoZSBhc3luYyBmdW5jdGlvbiB0byBleGVjdXRlXG4gKiBAcGFyYW0gcmV0cnlPcHRpb25zIHJldHJ5IG9wdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJldHJ5QXN5bmM8VD4oXG4gIGZuOiAoKSA9PiBQcm9taXNlPFQ+LFxuICByZXRyeU9wdGlvbnM/OiBSZXRyeU9wdGlvbnM8VD4sXG4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgeyBtYXhUcnksIGRlbGF5LCB1bnRpbCB9ID0ge1xuICAgIC4uLmdldERlZmF1bHRSZXRyeU9wdGlvbnMoKSxcbiAgICAuLi5yZXRyeU9wdGlvbnMsXG4gIH07XG4gIGFzc2VydERlZmluZWQobWF4VHJ5LCBgbWF4VHJ5IG11c3QgYmUgZGVmaW5lZGApO1xuICBhc3NlcnREZWZpbmVkKGRlbGF5LCBgZGVsYXkgbXVzdCBiZSBkZWZpbmVkYCk7XG4gIGNvbnN0IGNhblJlY2FsbCA9ICgpID0+IG1heFRyeSEgPiAxO1xuICBjb25zdCByZWNhbGwgPSBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZGVub0RlbGF5KGRlbGF5ISk7XG4gICAgcmV0dXJuIGF3YWl0IHJldHJ5QXN5bmMoZm4sIHsgZGVsYXksIG1heFRyeTogbWF4VHJ5ISAtIDEsIHVudGlsIH0pO1xuICB9O1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZuKCk7XG4gICAgY29uc3QgZG9uZSA9IHVudGlsID8gdW50aWwocmVzdWx0KSA6IHRydWU7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIGlmIChjYW5SZWNhbGwoKSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHJlY2FsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVG9vTWFueVRyaWVzKCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoIWlzVG9vTWFueVRyaWVzKGVycikgJiYgY2FuUmVjYWxsKCkpIHtcbiAgICAgIHJldHVybiBhd2FpdCByZWNhbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxufVxuIl19